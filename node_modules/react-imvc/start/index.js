"use strict";

/**
 * node server start file
 */
if (!process.env.NODE_ENV) {
  process.env.NODE_ENV = "production";
}

require("babel-polyfill");

var path = require("path");
var http = require("http");
var fetch = require("node-fetch");
var debug = require("debug")("app:server");
var createExpressApp = require("../entry/server");
var getConfig = require("../config");
var createPageRouter = require("../page/createPageRouter");

createExpressApp = createExpressApp.default || createExpressApp;
getConfig = getConfig.default || getConfig;
createPageRouter = createPageRouter.default || createPageRouter;

module.exports = function start(options) {
  var config = getConfig(options);
  var app = createExpressApp(config);
  var port = config.port;

  /**
   * make fetch works like in browser
   * when url starts with //, prepend protocol
   * when url starts with /, prepend protocol, host and port
  */
  global.fetch = function (url, options) {
    if (url.startsWith("//")) {
      url = "http:" + url;
    }
    if (url.startsWith("/")) {
      url = "http://localhost:" + port + url;
    }
    return fetch(url, options);
  };

  /**
   * set port from environment and store in Express.
   */
  app.set("port", port);

  /**
   * Create HTTP server.
   */

  var server = http.createServer(app);

  var pageRouter = createPageRouter(config);

  // 添加 renderPage 方法，让自定义的 routes 里可以手动调用，走 IMVC 的渲染流程
  app.use(function (req, res, next) {
    res.renderPage = pageRouter;
    next();
  });

  if (config.routes) {
    // get server routes
    var routes = require(path.join(config.root, config.routes));
    routes = routes.default || routes;
    Object.keys(routes).forEach(function (key) {
      var route = routes[key];
      if (typeof route === "function") {
        route(app, server);
      }
    });
  }

  app.use(pageRouter);

  // catch 404 and forward to error handler
  app.use(function (req, res, next) {
    var err = new Error("Not Found");
    err.status = 404;
    res.render("404", err);
  });

  // error handlers

  // development error handler
  // will print stacktrace
  if (app.get("env") === "development") {
    app.use(function (err, req, res, next) {
      res.status(err.status || 500);
      res.send(err.stack);
    });
  }

  // production error handler
  // no stacktraces leaked to user
  app.use(function (err, req, res, next) {
    res.status(err.status || 500);
    res.json(err.message);
  });

  /**
   * Event listener for HTTP server "listening" event.
   */

  function onListening() {
    var addr = server.address();
    var bind = typeof addr === "string" ? "pipe " + addr : "port " + addr.port;
    debug("Listening on " + bind);
    console.log("Listening on " + bind);
  }

  /**
  * Event listener for HTTP server "error" event.
  */

  function onError(error) {
    if (error.syscall !== "listen") {
      throw error;
    }

    var bind = typeof port === "string" ? "Pipe " + port : "Port " + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
      case "EACCES":
        console.error(bind + " requires elevated privileges");
        process.exit(1);
        break;
      case "EADDRINUSE":
        console.error(bind + " is already in use");
        process.exit(1);
        break;
      default:
        throw error;
    }
  }

  return new Promise(function (resolve, reject) {
    /**
    * Listen on provided port, on all network interfaces.
    */
    server.listen(port);
    server.on("error", onError);
    server.on("listening", onListening);
    server.on("error", reject);
    server.on("listening", function () {
      return resolve({ server: server, app: app });
    });
  });
};

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}