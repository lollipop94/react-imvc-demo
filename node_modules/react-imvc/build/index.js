'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var startStaticEntry = function () {
	var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(config) {
		var staticEntryConfig, _ref2, server, url, response, html, staticEntryPath;

		return regeneratorRuntime.wrap(function _callee$(_context) {
			while (1) {
				switch (_context.prev = _context.next) {
					case 0:
						if (config.staticEntry) {
							_context.next = 2;
							break;
						}

						return _context.abrupt('return');

					case 2:
						console.log('start generating static entry file');

						staticEntryConfig = _extends({}, config, {
							root: path.join(config.root, config.publish),
							publicPath: config.publicPath || '.',
							appSettings: _extends({}, config.appSettings, {
								type: 'createHashHistory'
							}),
							SSR: false
						});
						_context.next = 6;
						return start({
							config: staticEntryConfig
						});

					case 6:
						_ref2 = _context.sent;
						server = _ref2.server;
						url = 'http://localhost:' + config.port + '/__CREATE_STATIC_ENTRY__';

						console.log('fetching url:' + url);
						_context.next = 12;
						return fetch(url);

					case 12:
						response = _context.sent;
						_context.next = 15;
						return response.text();

					case 15:
						html = _context.sent;
						staticEntryPath = path.join(config.root, config.publish, config.static, config.staticEntry);


						server.close();

						return _context.abrupt('return', new Promise(function (resolve, reject) {
							fs.writeFile(staticEntryPath, html, function (error) {
								error ? reject(error) : resolve();
							});
						}));

					case 19:
					case 'end':
						return _context.stop();
				}
			}
		}, _callee, this);
	}));

	return function startStaticEntry(_x) {
		return _ref.apply(this, arguments);
	};
}();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

process.env.NODE_ENV = process.env.NODE_ENV || 'production';

var fs = require('fs');
var del = require('del');
var path = require('path');
var gulp = require('gulp');
var webpack = require('webpack');
var start = require('../start');
var getConfig = require('../config');
var createGulpTask = require('./createGulpTask');
var createWebpackClientConfg = require('./createWebpackClientConfig');

getConfig = getConfig.default || getConfig;

module.exports = function build(options) {
	var config = getConfig(options);
	return Promise.resolve().then(function () {
		return delPublish(path.join(config.root, config.publish));
	}).then(function () {
		return startGulp(config);
	}).then(function () {
		return startWebpack(config);
	}).then(function () {
		return startStaticEntry(config);
	}).catch(function (error) {
		return console.error(error);
	});
};

function delPublish(folder) {
	console.log('delete publish folder: ' + folder);
	return del(folder);
}

function startWebpack(config) {
	var webpackConfig = createWebpackClientConfg(config);
	return new Promise(function (resolve, reject) {
		webpack(webpackConfig, function (error, stats) {
			if (error) {
				reject(error);
			} else {
				if (config.webpackLogger) {
					console.log('[webpack:build]', stats.toString(config.webpackLogger));
				}
				resolve();
			}
		});
	});
}

function startGulp(config) {
	createGulpTask(config);
	return new Promise(function (resolve, reject) {
		gulp.start('default', function (error) {
			if (error) {
				reject(error);
			} else {
				resolve();
			}
		});
	});
}